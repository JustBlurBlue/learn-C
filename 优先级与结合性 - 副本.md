 **括号只能改变运算符的结合律，不能改变表达式的求值顺序** 

*编译器遵循优先级与结合性，但是可以自己决定求值顺序（意味着不同编译器顺序可能不同）*

*解决方案：当需要使用特殊运算顺序时，使用变量暂时存储中间值*

## ++，--

<u>*的优先级低于 + +，- - /u>



前缀：先增，后复制一份表达拷贝作为表达

后缀：先复制一份表达拷贝作为表达，后增

# 表达式的值

## =

返回右边的值

## <,>,!=，==(所有关系操作符)

返回整型值

真：1

假：0

*条件判断中只要表达式的值 > 0则会认定此时为真*

## !

真假对换

## a？b：c

计算a

若a为真，则执行并返回b

若a为假，则执行并返回c

## ,

自左向右逐个求值

返回最后一个表达式的值



# 布尔值（真与假）

C不具备显式的布尔类型，所以用整数代替

可以事先宏定义

```c
#define FALSE 0
#define TURE 1
```

或者用

```c
if(a!=0)/*显式判断*/
```

# 寻常算数转换

操作符的各个数要属于同一类型，系统会自动转化

```c
long double
double
float
unsigned long int 
long int 
unsigned int 
int
```

排名低的自动转换为排名高的

```c
int a=5000,b=25;
long c = a*b;
```

在16位整型机器上会出错

因为a，b均为int 

但计算的结果超出了int的最大范围



strlen返回的是unsigned int   ；

```c
if(strlen(x)>=strlen(y))
if(strlen(x)>=strlen(y)>=0)//永远为真
```



# 隐式类型转换

算数运算时以缺省类型的精度来进行

例如char会被提升为int进行运算