



# 数据类型与表达式

## 变量 

| 类型     |      |      |
| -------- | ---- | ---- |
| 存储类型 |      |      |
| 链接属性 |      |      |
| 作用域   |      |      |





## 整型:yum:以二进制表示十进制

### 1.char（8bit）

- 2^7   ~   2^7  - 1

*调用<limits.h>查找定义范围*

### 2.short（16bit）

### 3.int（32bit）

### 4.long(32bit)

### 5.long long(64bit)

<u>关于 unsigned</u>

添加在类型名前

使最高位不表示正负，而拓宽类型在正数方向能表示的范围

<u>关于正负转化</u>

1.   第一个1前全0
2.   第一个1得1
3.   后面全取反

## 浮点型（仅能十进制）

*调用<float.h>查询界限*

#### 一，类型



#### 二，两种形式

##### 1.小数形式

##### 2.指数形式：整数.小数e（E）指数

ep：3.14*10^-3  ---->   3.14e-3

*实际存储方式是分成三部分，第一部分正负，第二部分指数，第三部分数字*

## 指针(4BIT)

存储地址

*指针声明时不会自动分配任何内存*

<u>在定义指针时  " * "  作为说明符号

在使用指针时  " * "  作为访问目标变量的运算符</u>

### 空指针

暂时没有赋值的指针的初始化，NULL值为0

对NULL指针进行访问是绝对错误的，但是大多数编译器不会提示

```c
char *p=NULL;
```

<u>永远不要使用没初始化的指针</u>

### const

#### 指向const的指针

指向const的指针，代表指针所指向的变量的值不能更改（const变量必用，普通变量可用）；
有两种形式：可以不用初始化，因为指向可以变更；

```c
const int* p1;
int const* p2;
```

#### const指针

const指针，代表指针的指向不能更改；
指针作为变量，const指针代表指针的值不能变化，所以const指针必须初始化，就是要在定义的时候把指针的值（指针的指向）定下来；

```c
int a = 10;
int* const p3 = &a; 
```

#### 指向const的const指针

指向const的const指针，代表指针和指针指向的值都不能变更，兼具上述两者共同特性，也需要初始化；

```c
int b = 5;
const int* const p4 = &b;
```

#### const修饰数组

使用const来修饰数组声明了一个常量的数组，是对数组里面数据的一种保护

但是用指针间接访问依然可以修改

```c
const int days[5] = {1,2,3,4,5};//int const days[5]一样
//想要把days[0]重新赋值为6，报错
days[0] = 6;
//Cannot assign to variable 'days' with const-qualified type 'const int [5]'
```

#### const修饰形式参数

需要注意的是并不要求传进来的参数是const量（或者变量）

而是函数内部将这个传入的参数解释为这种类型以使用

指针形参都建议声明为const

<u>*但是const类型数据在需要传入时必须使用const类型数据声明，const类型必须使用下面的foo2或foo3进行声明*</u>

```c
void foo( int *const bar);
//foo接受一个指针，并把这个指针当做常量对待
void foo1(int *bar);
//foo1声明接受一个普通指针
void foo2(int const *bar);
//foo接受一个指针，并把这个指针所指的内容当做常量对待
void foo3(const int* const bar);
//foo接受一个指针，并把这个指针所指的内容以及指针本身当做常量对待
```

### 指针的操作

1.同种数据类型的指针变量之间可以相互赋值

2.指针类型应与所指变量类型相等

指针类型（去掉一个*之后占用字节的多少）决定了它所能访问的内存大小

如 int 指针访问 4 bit

​    char 指针访问 1 bit

3.指针必须指向一块有意义的内存

### 指针运算

1.赋值运算

2.取地址 " & " 和去内容 " * " 互为逆运算

3.指针与整数的加减运算

移动所能访问的内存大小的长度

Ep：
Char 指针 + 1 则向前 1bit

Int 指针 ＋ 1 则向前 4bit

4.指针的关系运算

比较指针内存储的地址大小 --> 判定指针位置

或看指针是否指向同一内存

常与空（NULL）进行比较

<,>,++,!=

*利用指针关系替代计数器可以优化程序*

5.指针之间的加减

如 指针  +  指针

只有两个指针都指向同一个数组中的元素时，才允许此操作

结果的类型为 ptrdiff_t 

这是一种有符号的整数类型

值为以指针大小为单位的距离



### 多重指针

如题示意，必须，指向指针的指针

 对于二重指针来说 它的类型只决定了它在一维层面上的位移

 而在指向指针的那个维度上  所有二重指针都进行加减运算时都只是位移4个字节 也就是指针的大小

### 数组指针   与   指针数组

##### 数组指针 

即 指向数组的指针

可以用于修改数组中的数据

Ep:

```c
 int（*p）[10]
```

则p为指针  指向有10个元素  且  数据类型为int 的数组

若（p+1）则指针所指地址向下移动 4*10 字节

##### 指针数组

即  由指针  构成的数组

Ep:

```c
int *p[10]
```



*理解：先执行下标引用   - - > p是某种类型的数组（个数为10）*

*在引用取得一个元素后，又执行了间接访问操作，从而得到了 int 类型*

*因此其是一个数组 p  内含有 10个  int类型 的指针 *

###### 字符串指针数组

数组名为指针常量(不可修改)

```c
char *s[] = {"12", "345", "5678"};
printf("%p", s[2]);
```

数组s内是三个指针

s[0]指向第一个字符串常量

s[1]指向"345"

s[2]指向"5678"

则s[0]与s[1]差3字节  分别存储了 1,2,\0 的const地址

s[1]与s[2]差4字节     分别存储了3，4，5,  \0 的const地址![](D:\笔记\QQ截图20240914230304.png)

字符串实际地址在const区（不可改变的区）

字符指针数组指向的字符串可以是不规则长度，提升空间利用率

最好加一个NULL指针作为最后元素以判定界限

###### 与二维数组的区别

```c
char s[][3]={"ks","y","cat"}
```

| k    | s    | 0    |
| ---- | ---- | ---- |
| y    | 0    | 0    |
| c    | a    | t    |

此时字符之间有空位

```c
char *s[3]={"ks","y","cat"}
```

| s[0] | "ks"  |
| ---- | ----- |
| s[1] | "y"   |
| s[2] | "cat" |

此时字符串是连续存储的

指针数组本身也需要4*3=16字节的空间

## 数组



#### 数组名

存放该数组在内存中的首地址（本质是指针常量，不能给其赋值（不能更改））

a [ i ]   * ( a + i )  本质上相同

*下标访问效率不会超过间接访问*



*指针常量意味着不能移动改变( 如 + + 改变 )，只能访问*

通过加减表示数组中的不同元素



在作为形式参数时

仅传入地址拷贝（也就是说丢失了数组长度）

建议

```c
void f(int const * p)
    /*
    const作用
    1.良好阅读（反正数组名本身就是int const*）
    2.编译器因此可以捕捉到任何试图修改该指针形参的意外错误
    3.允许向函数传递其他const指针
    */
```

关于const详细见指针

#### 关于初始化

###### 存储类型

缺省储存类型为auto，每次进入含有数组的代码块时有隐式语句对其赋值以初始化

static 使得其可以把数据存储于RAM数据段（仅初始化一次）

###### 自动化

省略 [ ] 内数字，编译器自动根据长度设置数组

#### 多维数组

除了最低维存放真的变量数据

其余都为<u>常量</u>指针 数组（指向数组的指针，不可修改）

即仍然是几个存储着地址的内存组成的数组

 a [ x ] [ y ]

1. a 代表二维数组的首地址，也是第0行的首地址（高维）

2. a + i 或者&a [ i ] 代表第 i 行地址，每次+1会移动一行

3. a此时是一个指向整型数组的指针

   ###### 多维数组的指针

   ```c
   int (*p)[5];
   ```

   声明了一个指向  长度为5整型数组   的指针

   ###### 传参

   同普通数组，传入地址

   ```c
   void func2(int (*a)[10])
   ```

   ```c
   void func2(int a[][10])
   ```

   第一个下标根据包含10个元素的整型数组长度调整；

   第二个下标根据整型的长度调整；

   必须知道第二个及以后各维的长度才能对各下标进行求值；

##### 顺序

按行顺序存放所有元素（地址）

## 结构

自定义数据类型

可以包含数组  指针  甚至是其他结构（若包含结构中有同名成员也不会冲突）

包含结构指针常用于链表或数

### 声明

#### 完整声明

```c
struct s
{
int num;
char name[100];
char sex;
};
```

s为对变量类型的取名

{}内的各种类型说明

为结构体s中的成员变量

#### 不完整声明

```c
struct B;//结构标签：此时已经声明了B但是没有说明其成员变量，即不完整声明
struct A{
struct B *p;//在A中得以声明指向类型B的指针
}
struct B{
struct A *p;
}

```



### 初始化 结构体

```c
struct s k1=
{
56,
"Jack",
'M',
};
```

struct s为变量类型名

k1 为变量名

{}内是对各种成员变量的初始化 

如果初始列表的值不够  则会使用缺省值

若内含有其他结构  则可以嵌套声明

### 成员变量

//成员变量可以看作普通变量操作

#### "  .  "   与"  ->  "成员运算符号

（与下标引用优先级相同，高于&）

```c
k1.num
struct s *p = &k1;//设置一个指向s结构类型的指针，并初始化为k1的地址
(*p).num//  .  操作符优先级高于  *  ，故要括号
p->num//只能使用在结构指针指向结构变量的情况下
```



### 结构，指针和成员![QQ截图20240916112419](D:\笔记\QQ截图20240916112419.png)



| 结构x |           |                 |             |
| :---- | --------- | --------------- | ----------- |
| int a | char b[3] | struct x2 c     | struct x *d |
| 10    | 'H'       | int a:10        | 0           |
|       | ' i '     | int b[2]=-1与25 |             |
|       | '\0'      |                 |             |
|       |           |                 |             |

指针px指向结构x

#### 访问指针（指针本身）

px

###### 右值：

指针值（结构变量地址）

实际与第一个成员的地址相同（没用）

但该指针的类型就是指向结构（类型不同）

###### 左值：

修改结构变量

*注意：px+1不是一个合法的左值*

#### 访问结构

*px

###### 右值：

整个结构

可以把其赋予到类型相同的结构

用于 " . " 或" -> "操作符

传递给函数当参数

当函数返回值

###### 左值：

结构变量接受它所有成员的新值

*px+1是非法的，

因为*px的结果是一个结构

*（px+1）也是违法的

#### 访问结构成员

px->一个成员名

###### 右值：

操作符对px执行间接访问操作

它首先得到它所指向的结构

再访问该成员

*如果我们需要一个指向结构单个成员的指针？*

假设成员是int类型，名称为a

```c
int *pi;
pi = px;//此表达式非法，因为px与pi的类型并不同
pi = (int *)px;//可以执行，但是很危险
pi = &px -> a;//正确且简单
```

假设成员是int类型数组，名称为b

```c
px->b//不是一个合法的左值，是一个数组（实际为数组首地址）
px->b[1]//访问数组第一个元素
```

#### 访问嵌套的结构

假设结构s内含有结构c

px->c

###### 左值：

整个c结构   px->c的结果是一个结构

可用于 

px->c.a(如果c内有名称为a的成员（非数组结构什么的）)

其右值为结构s内结构c内的a的值

*px->c.b

取出数组b内的第一个元素

#### 访问指针成员

```c
struct x y;
px->d=&y;
```

指针d指向结构y

px->d得到的是一个指向结构y的指针

理解：

px->d->a   y内为int a的值

px->d->b    y内b的数组名（地址）

px->d->c    y内的结构

px->d->c.a   为y内的结构c内的int a的值

px->d->c.b[1]   为y内的结构c内的char b[1]的值

### 结构的存储分配

因为大部分系统要求严格分配空间，需要对齐内存

故而再声明结构时，变量的顺序是会影响结构的大小的

Ep：
struct a

| char x |      |      |      | int y     |
| ------ | ---- | ---- | ---- | --------- |
| 1000   | 1001 | 1002 | 1003 | 1004-1008 |

总共8字节

struct b

| int x |      |      |      | char y |
| ----- | ---- | ---- | ---- | ------ |
| 1000  | 1001 | 1002 | 1003 | 1004   |

总共5字节

###### offsetof宏(stddef.h)

offsizeof(结构类型名，成员)

返回一个size_t

表示此成员距离结构开始偏移了几个字节

Ep:

```c
offsetof(b,y)//返回4
```

### 作为函数参数

结构变量是一个标量，可作为参数传递

但是这样做并不合适

因为它大，占用堆栈多

所以一般是传入指向它的指针（除非结构本身很小）

```c
void print(register transaction const *trans);//加const可以防止指针指向的变量被修改
```

### 位域

可以作为结构成员

位域只能是int，signed int ，unsigned int，snu

冒号后的整数（不超过所声明的最大长度）指定该成员占用的位（bit）的数目，若缺省则为声明长度

位域存储在一个变量长度（如int 有32bit）中，不可分隔

完全可以用位移实现

移植性差

```c
struct//只用于一个变量，省略了结构名
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
```

status 变量将占用 4 个字节的内存空间（32位）

但是只有 2 位被用来存储值（32位）

Ep：

```c
struct CHAR{
    unsigned ch   :7;
    unsigned font :6;
    unsigned size :19;//16位机器上这个可能非法
    unsigned      ：4//空域
}
```

如果是在32位机器上

会创建

| ch   | font | size | //   |
| ---- | ---- | ---- | ---- |
| 7    | 6    | 19   | 4    |

sizeof(struct 名)= 8  

或者

|      | size | font// | ch   |
| :--- | ---- | ------ | ---- |
| 4    | 19   | 6      | 7    |

sizeof(struct 名)= 8

//处为分隔位置

右到左或左到右（决定于编译）

顺序很重要！！影响结构体大小（因为有内存对齐）

无法对位域成员取地址，因为地址是以字节而不是以bit作单位的

位段的最大作用是访问某些硬件设备的寄存器，简化源代码，但削弱了移植性

## 联合

同一数据（位都相同），不同解释

可以作为结构成员，也可包含结构

可包含位域



*据说，最好的方法是在联合中存储指向不同成员的指针（动态内存分配）*

### 声明

```c
union x{//若此联合形式只用一次，则可以省略x
float f;//解释成果
int i;
char x;
int k:6;
}fi;//fi为联合变量名//仅以变量名初始化时使用首个成员类型

//用法同于struct
```

![ae255954ad42d085cb898aea7592e049](D:\笔记\ae255954ad42d085cb898aea7592e049.png)



可以用于判断内存高低端存储



可以用sizeof判断联合大小，通常是字节最大的成员大小

#### 变体记录

可以包含结构体

用结构体判断类型并保存



Ep：

```c
union Message {
    struct {
        char type;
        int data;
    } msg1;
    struct {
        char type;
        float value;
    } msg2;
};
 
void handleMessage(union Message *msg) {
    if (msg->msg1.type == 'A') {
        printf("Message 1: %d\n", msg->msg1.data);
    } else if (msg->msg2.type == 'B') {
        printf("Message 2: %f\n", msg->msg2.value);
    }
}
```







## typedef重命名

```c
typedef 原变量名 新变量名;
```

用空格分隔

或者

```c
typedef 声明变量 改变量名;
```

指针

```c
typedef char *p;/*将char型指针改名为了p*/
```

## 枚举

理解：不变常量数组，但每个元素有名称

配合typedef食用更佳

```c
enum Color {RED,YELLO,BLUE};/*定义了enum Color类型变量*/
enum Color you=RED;/*声明变量you 初始化为RED*/
```

元素的值：必须为整型   从首个元素值的大小++增大（首个元素默认为0）

当然也可以给初始赋值

Ep：

```c
enum Color {RED=555,YELLOW=111,BLUE};
```

则BLUE为112

## 常量

const关键字来声明



## 关于字符



### 字符数组

```c
char a[]={"123"};
char a[]={'1','2','3'};
```

"123"

其初始化时为一个 初始化列表

在其他任何地方 都表示字符串常量

### 字符串常量

是一串被锁定在一起的字符，包括结束符"\0"（类似相当于const 字符数组）

通过指针访问

```c
char *a="123";
```

指针a被初始化为指向这个字符串常量的存储地址



字符串指针数组







